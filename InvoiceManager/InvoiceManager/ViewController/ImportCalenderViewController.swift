//
//  ImportCalenderViewController.swift
//  InvoiceManager
//
//  Created by 鈴木啓司 on 2022-06-23.
//

import UIKit
import GoogleSignIn
import GoogleAPIClientForREST


// test model for development. we need to adjust when real models are created
struct StudentTest{
    let name: String
    let email: String
}

struct EventTest: Hashable{
    
    let id: String
    let title: String
    let attendees: [StudentTest]
    let startTime: String // ex 19:00
    let finishTime: String // ex 21:00
    let date: String // ex 2022/4/27
    var isTargetForInvoice: Bool
    
    func hash(into hasher: inout Hasher) {
        hasher.combine(title)
    }
    static func == (lhs: EventTest, rhs: EventTest) -> Bool {
        return lhs.id == rhs.id
    }
}

struct ImportedDataTest{
    var data = [String: [EventTest]]()
//    var data = [[String: [EventTest]]]()
}

var sampleStudent = StudentTest(name: "sampleStudent", email: "sample.com")
var sampleEventA = EventTest(id: "a", title: "class A", attendees: [sampleStudent, sampleStudent], startTime: "19:00", finishTime: "21:00", date: "dd/mm/yyyy", isTargetForInvoice: false)
var sampleEventB = EventTest(id: "b", title: "class A", attendees: [sampleStudent, sampleStudent, sampleStudent], startTime: "19:00", finishTime: "22:00", date: "dd/mm/yyyy", isTargetForInvoice: false)
var sampleEventC = EventTest(id: "c", title: "class B", attendees: [sampleStudent], startTime: "19:00", finishTime: "23:00", date: "dd/mm/yyyy", isTargetForInvoice: false)
var sampleImportedData = ImportedDataTest(data: ["class A": [sampleEventA, sampleEventB], "class B": [sampleEventC]])


class ImportCalenderViewController: UIViewController, EventSelectBoxDelegate {

    typealias DataSourceType = UICollectionViewDiffableDataSource<String, EventTest>
    
    var dataSource: DataSourceType!
    var sections = [String]()
    var selectedEventsName = [String]()
    
    @IBOutlet var fromField: UITextField!
    @IBOutlet var toField: UITextField!
    @IBOutlet var importButton: UIButton!
    @IBOutlet var calenderEventsCollectionView: UICollectionView!
    
    // test client id (generated by following instruction of  https://developers.google.com/identity/sign-in/ios/start-integrating)
    lazy var signInConfig: GIDConfiguration = {
        let clientId = ProcessInfo.processInfo.environment["OAUTH_CLIENT_ID"]!
        return GIDConfiguration(clientID: clientId)
    }()
    
    // add access scope for google apis
    let scopes = [
        "https://www.googleapis.com/auth/calendar.readonly",
        "https://www.googleapis.com/auth/calendar.events.readonly"
    ]
    
    var fromDate: Date?
    var toDate: Date?
    
    let datePicker = UIDatePicker()
    var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        createDatePicker()
      
        //MARK: create display collection view by Tomo
        calenderEventsCollectionView.collectionViewLayout = createLayout()
        createDataSource()
        calenderEventsCollectionView.register(EventNamedSectionHeaderView.self, forSupplementaryViewOfKind: "header-element-kind", withReuseIdentifier: EventNamedSectionHeaderView.reuseIdentifier)
        
    }
    
    func createToolBar() -> UIToolbar {
        let toolBar = UIToolbar()
        toolBar.sizeToFit()
        
        let doneButton =  UIBarButtonItem(barButtonSystemItem: .done, target: nil, action: #selector(doneButtonTapped))
        toolBar.setItems([doneButton], animated: true )
        
        return toolBar
    }
    
    func createDatePicker() {
        datePicker.preferredDatePickerStyle = .wheels
        datePicker.datePickerMode = .date
        datePicker.minimumDate = Date.now
        
        fromField.inputView = datePicker
        fromField.text = dateFormatter.string(from: Date.now)
        fromField.inputAccessoryView = createToolBar()
        
        let aMonthLater = Date(timeInterval: 2600000, since: Date.now)
        toField.inputView = datePicker
        toField.text = dateFormatter.string(from: aMonthLater)
        toField.inputAccessoryView = createToolBar()
    }
    
    //MARK: collection view setting by Tomo

    func createLayout() -> UICollectionViewCompositionalLayout{
        
        let layout = UICollectionViewCompositionalLayout{ (sectionIndex, layoutEnvironment) -> NSCollectionLayoutSection in
            
            let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1), heightDimension: .fractionalHeight(1))
            let item = NSCollectionLayoutItem(layoutSize: itemSize)
            
            let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1), heightDimension: .absolute(60))
            let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize, subitem: item, count: 1)
            
            let headerSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1), heightDimension: .absolute(40))
            let sectionHeader = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerSize, elementKind: "header-element-kind", alignment: .top)
            sectionHeader.pinToVisibleBounds = true
    
            let section = NSCollectionLayoutSection(group: group)
            section.boundarySupplementaryItems = [sectionHeader]
            
            return section
        }
        return layout
    }
    
    // here is the place where async function to access to google api and get data will be
    func createDataSource(){
        dataSource = .init(collectionView: calenderEventsCollectionView, cellProvider: { (collectionView, indexPath, item) -> UICollectionViewCell in
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "CalenderEvent", for: indexPath) as! calenderEventsCollectionViewCell
            cell.dateLabel.text = item.date
            cell.timeLabel.text = "\(item.startTime) - \(item.finishTime)"
            cell.attendeesListLabel.text = {
                let attendeesNameArray = item.attendees.map {$0.name}
                return attendeesNameArray.joined(separator: ", ")
            }()
            return cell
        })
        
        dataSource.supplementaryViewProvider = { (collectionView, kind, indexPath) in
            let header = collectionView.dequeueReusableSupplementaryView(ofKind: "header-element-kind", withReuseIdentifier: EventNamedSectionHeaderView.reuseIdentifier, for: indexPath) as! EventNamedSectionHeaderView
            header.eventName = Array(sampleImportedData.data.keys)[indexPath.section]
            header.delegate = self
            return header
        }
        
        var snapshot = NSDiffableDataSourceSnapshot<String, EventTest>()
        sampleImportedData.data.forEach { (eventName, events) in
            snapshot.appendSections([eventName])
            snapshot.appendItems(events, toSection: eventName)
        }
        sections = snapshot.sectionIdentifiers
        dataSource.apply(snapshot)
        
    }
    
    
    @objc func doneButtonTapped() {
        if fromField.isFirstResponder {
            fromDate = datePicker.date
            self.fromField.text = dateFormatter.string(from: datePicker.date)
        } else {
            toDate = datePicker.date
            self.toField.text = dateFormatter.string(from: datePicker.date)
        }
        self.view.endEditing(true)
        
        if let fromDate = fromDate, let toDate = toDate {
            if fromDate < toDate {
                importButton.isEnabled = true
            } else {
                importButton.isEnabled = false
            }
        }
        
    }
    
    
    @IBAction func importButtonTapped(_ sender: UIButton) {
        //implementation for previous sign-in instance
        //        if GIDSignIn.sharedInstance.hasPreviousSignIn() {
        //            GIDSignIn.sharedInstance.restorePreviousSignIn()
        //            self.fetchCalendarEvents(for: GIDSignIn.sharedInstance.currentUser!)
        //        } else { }
        
        // initial login
        GIDSignIn.sharedInstance.signIn(
            with: signInConfig,
            presenting: self,
            hint: nil,
            additionalScopes: scopes
        ) { user, error in
            // implement handler
            print("\(String(describing: user)) logged in")
            
            guard let user = GIDSignIn.sharedInstance.currentUser else { return }
            
            // fetch events for the last 30 days
            let period: TimeInterval = 60*60*24*30
            let startDateTime = GTLRDateTime(date: Calendar.current.startOfDay(for: Date()-period))
            let endDateTime = GTLRDateTime(date: Date().addingTimeInterval(60*60*24))
            
            self.fetchCalendarEvents(for: user, from: startDateTime, to: endDateTime)
        }
    }
    
    
    // test function for checking calendar event fetch
    func fetchCalendarEvents(for user: GIDGoogleUser, from: GTLRDateTime ,to: GTLRDateTime) {
        let calendarService = GTLRCalendarService()
        let authentication = user.authentication
        calendarService.authorizer = authentication.fetcherAuthorizer()
        
        let eventsListQuery = GTLRCalendarQuery_EventsList.query(withCalendarId: "primary")
        
        eventsListQuery.timeMin = from
        eventsListQuery.timeMax = to
        calendarService.executeQuery(eventsListQuery) { ticket, result, error in
            guard error == nil, let items = (result as? GTLRCalendar_Events)?.items else {
                return
            }
            if items.count > 0 {
                // Do stuff with your events
                self.alert(title: "Fetched events", message: String(describing: items))
            } else {
                // No events
                print("sign in before fetch!")
            }
        }
    }
    
    func alert(title:String, message:String) {
        let alertController = UIAlertController(
            title: title,
            message: message,
            preferredStyle: .alert
        )
        alertController.addAction(
            UIAlertAction(
                title: "OK",
                style: .default,
                handler: nil
            )
        )
        present(alertController, animated: true)
    }
    
    //MARK: user interact action by Tomo
    func checkmarkTapped(on eventName: String) {
        
        if selectedEventsName.contains(where: {$0 == eventName}){
            selectedEventsName = selectedEventsName.filter { $0 != eventName}
        }else{
            selectedEventsName.append(eventName)
        }
        
        // each evet's property change
        //        sampleImportedData.data[eventName]! = sampleImportedData.data[eventName]!.map{ event in
        //            return EventTest(id: event.id, title: event.title, attendees: event.attendees, startTime: event.startTime, finishTime: event.finishTime, date: event.date, isTargetForInvoice: !event.isTargetForInvoice)
        //        }
    }
    
    @IBAction func nextButtonTapped() {
        print(selectedEventsName)
        let exportData = selectedEventsName.map { eventName in
            return sampleImportedData.data[eventName]!
        }
        print(exportData)
    }
}
